# 课时31：函数调用序列欺骗

## 1. 课程目标

学习通过伪造函数调用栈来欺骗安全软件的行为检测。

---

## 2. 技术原理

安全软件通过监控调用栈来判断API调用是否可疑：

```
正常调用栈:
main() → CreateFileW() → NtCreateFile()

可疑调用栈:
shellcode() → NtCreateFile()  ← 没有正常的调用链
```

---

## 3. 实现方法

### 3.1 伪造返回地址

```cpp
#include <windows.h>

typedef NTSTATUS(NTAPI* pNtCreateFile)(
    PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK,
    PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);

void SpoofedCall() {
    // 获取kernel32中的合法地址作为伪造返回地址
    HMODULE hKernel32 = GetModuleHandleW(L"kernel32.dll");
    LPVOID pFakeReturn = (LPBYTE)hKernel32 + 0x1000;  // 合法地址
    
    pNtCreateFile NtCreateFile = (pNtCreateFile)GetProcAddress(
        GetModuleHandleW(L"ntdll.dll"), "NtCreateFile");
    
    // 使用汇编伪造调用栈
    // ... 需要汇编实现
}
```

### 3.2 间接调用

```cpp
// 通过系统API间接调用
void IndirectCall() {
    // 使用回调函数，让系统帮我们调用
    // 这样调用栈看起来正常
    
    EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL {
        // 在回调中执行敏感操作
        // 调用栈显示是从user32.dll发起的
        return FALSE;
    }, 0);
}
```

---

## 4. 课后作业

### 作业1：分析调用栈（必做）

1. 使用调试器观察正常和异常的调用栈
2. 理解安全软件的检测逻辑

### 作业2：间接调用（进阶）

1. 使用回调函数执行敏感操作
2. 观察调用栈变化

---

## 5. 下一课预告

下一课我们将学习更多函数序列欺骗技术。
