# 课时20：查杀原理

## 1. 课程目标

深入了解安全软件的查杀原理，为后续的免杀技术学习打下理论基础。

### 1.1 学习目标

- 理解杀毒软件的工作原理
- 掌握静态检测与动态检测的区别
- 了解机器学习在安全检测中的应用
- 学会分析样本被查杀的原因

---

## 2. 名词解释

| 名词 | 英文 | 解释 |
|------|------|------|
| **特征码** | Signature | 恶意软件的唯一标识字节序列 |
| **启发式检测** | Heuristic Detection | 基于行为和代码特征的检测 |
| **沙箱** | Sandbox | 隔离的执行环境 |
| **YARA规则** | - | 用于识别恶意软件的模式匹配规则 |
| **IOC** | Indicators of Compromise | 威胁指标 |
| **AI引擎** | - | 基于机器学习的检测引擎 |
| **云查杀** | Cloud Detection | 基于云端数据库的检测 |
| **AMSI** | Antimalware Scan Interface | Windows反恶意软件扫描接口 |

---

## 3. 检测技术分类

### 3.1 检测层次

```
┌─────────────────────────────────────────────────────────┐
│                    云端检测                              │
│  (文件哈希、信誉评分、大数据分析)                         │
├─────────────────────────────────────────────────────────┤
│                  机器学习引擎                            │
│  (特征提取、模型分类、异常检测)                          │
├─────────────────────────────────────────────────────────┤
│                  行为检测 (动态)                         │
│  (API监控、内存扫描、行为分析)                           │
├─────────────────────────────────────────────────────────┤
│                  启发式检测                              │
│  (代码结构、可疑API组合、熵值分析)                        │
├─────────────────────────────────────────────────────────┤
│                  特征码检测 (静态)                        │
│  (字节序列匹配、哈希比对)                                │
└─────────────────────────────────────────────────────────┘
```

---

## 4. 静态检测技术

### 4.1 特征码检测

```cpp
// 特征码示例
// 假设某恶意软件包含以下字节序列:
// 68 00 00 40 00 68 00 00 40 00 E8 xx xx xx xx

// YARA规则示例
/*
rule Malware_Example {
    meta:
        description = "Example malware signature"
        author = "Analyst"
    strings:
        $sig1 = { 68 00 00 40 00 68 00 00 40 00 E8 }
        $str1 = "evil_function" ascii
        $str2 = "MALWARE" wide
    condition:
        any of them
}
*/
```

### 4.2 哈希检测

```cpp
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>

// 计算文件MD5
BOOL GetFileMD5(LPCWSTR szFilePath, BYTE* pHash) {
    HANDLE hFile = CreateFileW(szFilePath, GENERIC_READ, FILE_SHARE_READ,
                               NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) return FALSE;
    
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    
    CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
    CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash);
    
    BYTE buffer[4096];
    DWORD bytesRead;
    while (ReadFile(hFile, buffer, sizeof(buffer), &bytesRead, NULL) && bytesRead) {
        CryptHashData(hHash, buffer, bytesRead, 0);
    }
    
    DWORD hashLen = 16;
    CryptGetHashParam(hHash, HP_HASHVAL, pHash, &hashLen, 0);
    
    CryptDestroyHash(hHash);
    CryptReleaseContext(hProv, 0);
    CloseHandle(hFile);
    
    return TRUE;
}
```

### 4.3 PE结构分析

```cpp
// 检查可疑的PE特征
typedef struct _SUSPICIOUS_FEATURES {
    BOOL bPackedEntropy;        // 高熵值（加壳）
    BOOL bSuspiciousImports;    // 可疑导入
    BOOL bNoExports;            // 无导出（DLL）
    BOOL bAbnormalSections;     // 异常区段
    BOOL bOverlayData;          // 覆盖数据
    BOOL bSelfModifying;        // 可写执行段
} SUSPICIOUS_FEATURES;

void AnalyzePE(LPVOID pPE, SUSPICIOUS_FEATURES* pFeatures) {
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pPE;
    PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)((LPBYTE)pPE + pDos->e_lfanew);
    
    // 检查入口点
    DWORD dwEP = pNt->OptionalHeader.AddressOfEntryPoint;
    
    // 检查区段
    PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNt);
    for (WORD i = 0; i < pNt->FileHeader.NumberOfSections; i++) {
        // 检查可写+可执行区段
        if ((pSection[i].Characteristics & IMAGE_SCN_MEM_WRITE) &&
            (pSection[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)) {
            pFeatures->bSelfModifying = TRUE;
        }
        
        // 检查熵值
        // CalculateEntropy(...);
    }
}
```

---

## 5. 动态检测技术

### 5.1 API监控

```cpp
// 安全软件Hook关键API
// 监控的典型API:

// 进程/线程操作
- CreateProcessW/A
- CreateRemoteThread
- NtCreateProcess/Thread

// 内存操作
- VirtualAllocEx
- VirtualProtectEx  
- WriteProcessMemory
- NtMapViewOfSection

// 注册表操作
- RegSetValueExW
- NtSetValueKey

// 网络操作
- connect
- send/recv
- WSAConnect
```

### 5.2 行为规则

```cpp
// 可疑行为组合示例

/*
规则1: 进程注入
IF:
  - CreateRemoteThread in other process
  - WriteProcessMemory to other process
  - VirtualAllocEx in other process
THEN:
  - Flag as SUSPICIOUS_INJECTION

规则2: 持久化
IF:
  - CreateFileW in Startup folder
  OR RegSetValueExW in Run/RunOnce keys
  OR CreateServiceW
THEN:
  - Flag as SUSPICIOUS_PERSISTENCE

规则3: 信息窃取
IF:
  - ReadFile on sensitive paths (browsers, credentials)
  - CreateFileW followed by network send
THEN:
  - Flag as SUSPICIOUS_EXFILTRATION
*/
```

### 5.3 沙箱分析

```cpp
// 沙箱环境检测（恶意软件视角）
BOOL IsInSandbox() {
    // 检查用户交互
    if (GetCursorPos(&pt) && pt.x == 0 && pt.y == 0) {
        // 可能是沙箱
    }
    
    // 检查运行时间
    if (GetTickCount64() < 600000) {  // 少于10分钟
        // 可能刚启动
    }
    
    // 检查进程数量
    // 真实系统通常有50+进程
    
    // 检查特定虚拟化特征
    // ...
}
```

---

## 6. 机器学习检测

### 6.1 特征提取

```
静态特征:
- PE头信息 (TimeDateStamp, 区段数, 导入数)
- 字符串特征 (恶意字符串比例)
- 导入函数 (高危API数量)
- 熵值分布
- 字节n-gram

动态特征:
- API调用序列
- 文件系统操作
- 注册表操作
- 网络行为
```

### 6.2 检测模型

```
常用算法:
- 随机森林 (Random Forest)
- 梯度提升 (XGBoost, LightGBM)
- 深度学习 (CNN, LSTM)
- 神经网络 (MLP)

训练数据:
- 恶意样本: VirusTotal, 恶意软件库
- 正常样本: 合法软件
```

---

## 7. 云查杀机制

### 7.1 工作流程

```
1. 本地计算文件哈希
2. 将哈希发送到云端
3. 云端查询数据库
4. 返回结果:
   - 已知恶意
   - 已知安全
   - 未知（上传样本进一步分析）
```

### 7.2 信誉系统

```
文件信誉评分因素:
- 数字签名状态
- 流行度（使用人数）
- 首次出现时间
- 来源网站信誉
- 关联的IOC
```

---

## 8. AMSI机制

### 8.1 AMSI工作原理

```cpp
// Windows AMSI扫描接口
// 用于扫描脚本和内存中的内容

#include <amsi.h>

// AMSI扫描示例
HRESULT ScanWithAMSI(LPCWSTR szContent) {
    HAMSICONTEXT hContext = NULL;
    HAMSISESSION hSession = NULL;
    AMSI_RESULT result;
    
    AmsiInitialize(L"MyApp", &hContext);
    AmsiOpenSession(hContext, &hSession);
    
    AmsiScanString(hContext, szContent, L"script", hSession, &result);
    
    if (result >= AMSI_RESULT_DETECTED) {
        printf("[!] 检测到恶意内容\n");
    }
    
    AmsiCloseSession(hContext, hSession);
    AmsiUninitialize(hContext);
    
    return S_OK;
}
```

### 8.2 AMSI扫描点

```
AMSI扫描位置:
- PowerShell脚本
- VBScript/JScript
- .NET程序集加载
- Windows Script Host
- Office宏
```

---

## 9. 免杀思路总结

| 检测类型 | 绕过思路 |
|----------|----------|
| 特征码检测 | 修改特征码、加密、混淆 |
| 哈希检测 | 任意修改使哈希变化 |
| 启发式检测 | 代码变形、正常化行为 |
| API监控 | 直接Syscall、Unhook |
| 行为检测 | 延时执行、分离操作 |
| 沙箱检测 | 环境检测、时间延迟 |
| 机器学习 | 添加正常特征、对抗样本 |
| 云查杀 | 离线环境、快速执行 |
| AMSI | Patch AmsiScanBuffer |

---

## 10. 课后作业

### 作业1：特征分析（必做）

1. 使用YARA编写一个简单的检测规则
2. 分析一个已知样本的静态特征

### 作业2：行为分析（进阶）

1. 使用Process Monitor分析程序行为
2. 记录可疑的API调用序列

### 作业3：检测实验（高级）

1. 分析某杀毒软件的检测逻辑
2. 研究被查杀样本的具体检测点

---

## 11. 下一课预告

下一课我们将学习特征码定位原理，掌握如何找出被检测的特征码位置。
