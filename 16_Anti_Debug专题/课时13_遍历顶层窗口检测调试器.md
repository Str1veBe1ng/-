# 课时13 遍历顶层窗口检测调试器

## 一、课程目标

本节课主要学习如何通过遍历系统顶层窗口列表并检查窗口属性来检测调试器。与普通窗口遍历不同，顶层窗口检测专注于那些位于Z轴最上层的窗口，这些窗口通常包括调试器界面。通过本课的学习，你将能够：

1. 掌握遍历顶层窗口列表的基本方法
2. 学会识别调试器窗口的特殊属性和特征
3. 理解基于窗口层级和属性的检测技术
4. 掌握多种顶层窗口遍历技术
5. 了解该技术的优势和局限性

## 二、名词解释表

| 名词 | 解释 |
|------|------|
| 顶层窗口 | 位于Z轴最上层的窗口，通常是应用程序的主窗口 |
| Z轴顺序 | 窗口在屏幕深度方向上的排列顺序 |
| WS_EX_TOPMOST | 窗口扩展样式，表示窗口始终置顶 |
| GetTopWindow | 获取指定窗口的顶层子窗口 |
| GetWindow | 获取与指定窗口有特定关系的窗口 |
| GW_HWNDNEXT | GetWindow函数的参数，获取下一个窗口 |
| GW_OWNER | GetWindow函数的参数，获取窗口的所有者 |

## 三、技术原理

### 3.1 顶层窗口概述

顶层窗口是指那些没有父窗口或所有者的窗口，它们直接属于桌面窗口。大多数应用程序的主窗口都是顶层窗口。调试器通常也会创建顶层窗口作为其主界面。

### 3.2 调试器窗口的特征

调试器窗口通常具有以下特征：

1. **窗口标题特征**：包含特定关键词如"OllyDbg"、"x64dbg"等
2. **窗口类名特征**：使用特定的窗口类名
3. **窗口样式特征**：可能具有特殊的窗口样式或扩展样式
4. **窗口位置特征**：通常位于屏幕的特定位置
5. **窗口层级特征**：可能设置为始终置顶

### 3.3 检测原理

通过遍历顶层窗口并分析其属性，可以发现调试器窗口的存在。与普通的EnumWindows相比，顶层窗口检测更加专注，能够减少误报。

## 四、代码实现

### 4.1 基于GetTopWindow的顶层窗口遍历

```cpp
#include <windows.h>
#include <stdio.h>
#include <vector>
#include <string>

// 窗口信息结构
typedef struct _TOP_WINDOW_INFO {
    HWND hwnd;
    std::string title;
    std::string className;
    RECT rect;
    DWORD styles;
    DWORD exStyles;
    BOOL isVisible;
    BOOL isTopmost;
} TOP_WINDOW_INFO, *PTOP_WINDOW_INFO;

// 常见调试器窗口标题列表
const char* g_debuggerTopTitles[] = {
    "OllyDbg",
    "[x32dbg]",
    "[x64dbg]",
    "WinDbg",
    "Microsoft (R) Windows Debugger",
    "IDA",
    "IDA Pro",
    "Cheat Engine",
    "Immunity Debugger",
    "radare2",
    "Process Hacker",
    "Process Monitor",
    "Wireshark",
    "Fiddler"
};

const int g_debuggerTopTitleCount = sizeof(g_debuggerTopTitles) / sizeof(g_debuggerTopTitles[0]);

// 字符串转小写
void ToLower(std::string& str) {
    for (auto& c : str) {
        c = tolower(c);
    }
}

// 检查窗口标题是否在黑名单中
BOOL IsDebuggerTopWindow(const std::string& windowTitle) {
    if (windowTitle.empty()) {
        return FALSE;
    }
    
    std::string lowerTitle = windowTitle;
    ToLower(lowerTitle);
    
    for (int i = 0; i < g_debuggerTopTitleCount; i++) {
        std::string lowerDebugger = g_debuggerTopTitles[i];
        ToLower(lowerDebugger);
        
        // 使用模糊匹配
        if (lowerTitle.find(lowerDebugger) != std::string::npos) {
            return TRUE;
        }
    }
    
    return FALSE;
}

// 获取顶层窗口信息
TOP_WINDOW_INFO GetTopWindowInfo(HWND hwnd) {
    TOP_WINDOW_INFO windowInfo = {0};
    windowInfo.hwnd = hwnd;
    
    // 获取窗口标题
    char title[1024];
    int titleLen = GetWindowTextA(hwnd, title, sizeof(title));
    if (titleLen > 0) {
        windowInfo.title = title;
    }
    
    // 获取窗口类名
    char className[256];
    int classLen = GetClassNameA(hwnd, className, sizeof(className));
    if (classLen > 0) {
        windowInfo.className = className;
    }
    
    // 获取窗口位置和大小
    GetWindowRect(hwnd, &windowInfo.rect);
    
    // 获取窗口样式
    windowInfo.styles = GetWindowLong(hwnd, GWL_STYLE);
    windowInfo.exStyles = GetWindowLong(hwnd, GWL_EXSTYLE);
    
    // 获取窗口状态
    windowInfo.isVisible = IsWindowVisible(hwnd);
    windowInfo.isTopmost = (windowInfo.exStyles & WS_EX_TOPMOST) != 0;
    
    return windowInfo;
}

// 基于GetTopWindow的顶层窗口遍历检测
BOOL DetectDebuggersViaGetTopWindow() {
    printf("=== GetTopWindow检测 ===\n");
    
    // 获取桌面窗口
    HWND desktop = GetDesktopWindow();
    if (desktop == NULL) {
        return FALSE;
    }
    
    // 获取第一个顶层窗口
    HWND topWindow = GetTopWindow(desktop);
    BOOL detected = FALSE;
    
    // 遍历所有顶层窗口
    while (topWindow != NULL) {
        // 获取窗口信息
        TOP_WINDOW_INFO windowInfo = GetTopWindowInfo(topWindow);
        
        // 检查可见的顶层窗口
        if (windowInfo.isVisible) {
            // 检查是否为调试器窗口
            if (IsDebuggerTopWindow(windowInfo.title)) {
                printf("检测到调试器顶层窗口:\n");
                printf("  标题: %s\n", windowInfo.title.c_str());
                printf("  类名: %s\n", windowInfo.className.c_str());
                printf("  位置: (%ld, %ld) - (%ld, %ld)\n", 
                       windowInfo.rect.left, windowInfo.rect.top,
                       windowInfo.rect.right, windowInfo.rect.bottom);
                printf("  置顶: %s\n", windowInfo.isTopmost ? "是" : "否");
                detected = TRUE;
            }
        }
        
        // 获取下一个顶层窗口
        topWindow = GetWindow(topWindow, GW_HWNDNEXT);
    }
    
    if (!detected) {
        printf("未检测到调试器顶层窗口。\n");
    }
    
    return detected;
}
```

### 4.2 基于GetWindow的完整窗口链遍历

```cpp
// 基于GetWindow的完整窗口链遍历检测
BOOL DetectDebuggersViaGetWindow() {
    printf("=== GetWindow检测 ===\n");
    
    // 从桌面窗口开始遍历
    HWND hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    std::vector<HWND> topLevelWindows;
    
    // 收集所有顶层窗口
    while (hwnd != NULL) {
        // 检查是否为顶层窗口（没有父窗口）
        if (GetParent(hwnd) == NULL) {
            topLevelWindows.push_back(hwnd);
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
    
    BOOL detected = FALSE;
    
    // 检查每个顶层窗口
    for (HWND topWindow : topLevelWindows) {
        TOP_WINDOW_INFO windowInfo = GetTopWindowInfo(topWindow);
        
        // 只检查可见窗口
        if (windowInfo.isVisible) {
            // 检查是否为调试器窗口
            if (IsDebuggerTopWindow(windowInfo.title)) {
                printf("检测到调试器窗口:\n");
                printf("  标题: %s\n", windowInfo.title.c_str());
                printf("  类名: %s\n", windowInfo.className.c_str());
                printf("  位置: (%ld, %ld) - (%ld, %ld)\n", 
                       windowInfo.rect.left, windowInfo.rect.top,
                       windowInfo.rect.right, windowInfo.rect.bottom);
                printf("  置顶: %s\n", windowInfo.isTopmost ? "是" : "否");
                detected = TRUE;
            }
        }
    }
    
    if (!detected) {
        printf("未检测到调试器窗口。\n");
    }
    
    return detected;
}

// 获取所有顶层窗口
std::vector<TOP_WINDOW_INFO> GetAllTopLevelWindows() {
    std::vector<TOP_WINDOW_INFO> windows;
    
    // 从桌面窗口开始遍历
    HWND hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    
    while (hwnd != NULL) {
        // 检查是否为顶层窗口
        if (GetParent(hwnd) == NULL) {
            TOP_WINDOW_INFO windowInfo = GetTopWindowInfo(hwnd);
            windows.push_back(windowInfo);
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
    
    return windows;
}
```

### 4.3 基于窗口所有者关系的检测

```cpp
// 基于窗口所有者关系的检测
BOOL DetectDebuggersViaOwnerRelationship() {
    printf("=== 窗口所有者关系检测 ===\n");
    
    auto topLevelWindows = GetAllTopLevelWindows();
    BOOL detected = FALSE;
    
    for (const auto& window : topLevelWindows) {
        if (window.isVisible) {
            // 检查窗口的所有者
            HWND owner = GetWindow(window.hwnd, GW_OWNER);
            
            // 如果窗口有所有者，检查所有者是否为调试器
            if (owner != NULL) {
                TOP_WINDOW_INFO ownerInfo = GetTopWindowInfo(owner);
                
                if (IsDebuggerTopWindow(ownerInfo.title)) {
                    printf("检测到调试器相关窗口:\n");
                    printf("  子窗口标题: %s\n", window.title.c_str());
                    printf("  所有者标题: %s\n", ownerInfo.title.c_str());
                    detected = TRUE;
                }
            }
        }
    }
    
    if (!detected) {
        printf("未检测到调试器相关窗口。\n");
    }
    
    return detected;
}

// 检测置顶调试器窗口
BOOL DetectTopmostDebuggerWindows() {
    printf("=== 置顶调试器窗口检测 ===\n");
    
    auto topLevelWindows = GetAllTopLevelWindows();
    BOOL detected = FALSE;
    
    for (const auto& window : topLevelWindows) {
        if (window.isVisible && window.isTopmost) {
            // 检查置顶窗口是否为调试器
            if (IsDebuggerTopWindow(window.title)) {
                printf("检测到置顶调试器窗口:\n");
                printf("  标题: %s\n", window.title.c_str());
                printf("  类名: %s\n", window.className.c_str());
                detected = TRUE;
            }
        }
    }
    
    if (!detected) {
        printf("未检测到置顶调试器窗口。\n");
    }
    
    return detected;
}
```

### 4.4 完整的顶层窗口检测实现

```cpp
// 顶层窗口检测工具类
class TopWindowDetector {
public:
    static void PrintTopLevelWindows() {
        printf("=== 所有顶层窗口列表 ===\n");
        
        auto windows = GetAllTopLevelWindows();
        int visibleCount = 0;
        
        for (const auto& window : windows) {
            if (window.isVisible) {
                visibleCount++;
                printf("标题: %-50s 类名: %-20s 位置: (%4ld,%4ld)\n", 
                       window.title.c_str(), 
                       window.className.c_str(),
                       window.rect.left, 
                       window.rect.top);
            }
        }
        printf("总计可见顶层窗口: %d 个\n\n", visibleCount);
    }
    
    static BOOL DetectKnownDebuggerTopWindows() {
        printf("=== 检测已知调试器顶层窗口 ===\n");
        
        auto windows = GetAllTopLevelWindows();
        BOOL detected = FALSE;
        
        for (const auto& window : windows) {
            if (window.isVisible) {
                if (IsDebuggerTopWindow(window.title)) {
                    printf("检测到调试器顶层窗口:\n");
                    printf("  标题: %s\n", window.title.c_str());
                    printf("  类名: %s\n", window.className.c_str());
                    printf("  位置: (%ld, %ld) - (%ld, %ld)\n", 
                           window.rect.left, window.rect.top,
                           window.rect.right, window.rect.bottom);
                    printf("  样式: 0x%08X\n", window.styles);
                    printf("  扩展样式: 0x%08X\n", window.exStyles);
                    detected = TRUE;
                }
            }
        }
        
        if (!detected) {
            printf("未检测到已知调试器顶层窗口。\n");
        }
        
        return detected;
    }
    
    static BOOL DetectSuspiciousTopWindows() {
        printf("=== 检测可疑顶层窗口 ===\n");
        
        auto windows = GetAllTopLevelWindows();
        BOOL detected = FALSE;
        
        // 模糊匹配模式
        const char* suspiciousPatterns[] = {
            "debug",
            "dbg",
            "analyze",
            "monitor",
            "hook",
            "trace",
            "disasm",
            "disassembler"
        };
        
        for (const auto& window : windows) {
            if (window.isVisible) {
                std::string lowerTitle = window.title;
                ToLower(lowerTitle);
                
                for (int i = 0; i < sizeof(suspiciousPatterns)/sizeof(suspiciousPatterns[0]); i++) {
                    if (lowerTitle.find(suspiciousPatterns[i]) != std::string::npos) {
                        printf("发现可疑顶层窗口:\n");
                        printf("  标题: %s\n", window.title.c_str());
                        printf("  类名: %s\n", window.className.c_str());
                        detected = TRUE;
                    }
                }
            }
        }
        
        if (!detected) {
            printf("未发现可疑顶层窗口。\n");
        }
        
        return detected;
    }
    
    static void AnalyzeWindowProperties() {
        printf("=== 窗口属性分析 ===\n");
        
        auto windows = GetAllTopLevelWindows();
        
        int topmostCount = 0;
        int toolWindowCount = 0;
        int appWindowCount = 0;
        
        for (const auto& window : windows) {
            if (window.isVisible) {
                if (window.isTopmost) {
                    topmostCount++;
                }
                
                if (window.exStyles & WS_EX_TOOLWINDOW) {
                    toolWindowCount++;
                }
                
                if (window.exStyles & WS_EX_APPWINDOW) {
                    appWindowCount++;
                }
            }
        }
        
        printf("置顶窗口数量: %d\n", topmostCount);
        printf("工具窗口数量: %d\n", toolWindowCount);
        printf("应用程序窗口数量: %d\n", appWindowCount);
        printf("\n");
    }
};
```

### 4.5 反调试实现

```cpp
// 简单的顶层窗口反调试
VOID SimpleTopWindowAntiDebug() {
    if (TopWindowDetector::DetectKnownDebuggerTopWindows()) {
        printf("检测到调试器顶层窗口存在！程序即将退出。\n");
        ExitProcess(1);
    }
}

// 多层次顶层窗口检测
BOOL MultiLayerTopWindowDetection() {
    // 第一层：精确匹配检测
    if (TopWindowDetector::DetectKnownDebuggerTopWindows()) {
        return TRUE;
    }
    
    // 第二层：模糊匹配检测
    if (TopWindowDetector::DetectSuspiciousTopWindows()) {
        return TRUE;
    }
    
    // 第三层：置顶窗口检测
    if (DetectTopmostDebuggerWindows()) {
        return TRUE;
    }
    
    // 第四层：所有者关系检测
    if (DetectDebuggersViaOwnerRelationship()) {
        return TRUE;
    }
    
    return FALSE;
}

// 增强版反调试
VOID EnhancedTopWindowAntiDebug() {
    // 多次检测
    for (int i = 0; i < 5; i++) {
        if (MultiLayerTopWindowDetection()) {
            printf("第%d次顶层窗口检测发现调试环境！\n", i + 1);
            
            // 随机化响应
            int response = rand() % 4;
            switch (response) {
            case 0:
                ExitProcess(0);
            case 1:
                printf("发生未知错误。\n");
                Sleep(5000);
                exit(1);
            case 2:
                // 执行错误指令
                __debugbreak();
            case 3:
                // 进入无限循环
                while (1) {
                    Sleep(1000);
                }
            }
        }
        
        // 随机延迟
        Sleep(rand() % 100 + 50);
    }
    
    printf("顶层窗口反调试检测通过。\n");
}
```

### 4.6 绕过顶层窗口检测的方法

```cpp
// 顶层窗口伪装技术
class TopWindowObfuscator {
public:
    // 修改当前进程主窗口标题
    static BOOL ChangeTopWindowTitle(const char* newTitle) {
        HWND hwnd = GetForegroundWindow();
        if (hwnd == NULL) {
            hwnd = GetActiveWindow();
        }
        
        if (hwnd != NULL) {
            if (SetWindowTextA(hwnd, newTitle)) {
                printf("顶层窗口标题已修改为: %s\n", newTitle);
                return TRUE;
            }
        }
        
        return FALSE;
    }
    
    // 取消窗口置顶
    static BOOL RemoveTopmostStyle(HWND hwnd) {
        if (hwnd == NULL) {
            hwnd = GetForegroundWindow();
        }
        
        if (hwnd != NULL) {
            LONG exStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
            exStyle &= ~WS_EX_TOPMOST;
            
            if (SetWindowLong(hwnd, GWL_EXSTYLE, exStyle)) {
                // 更新窗口
                SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, 
                           SWP_NOMOVE | SWP_NOSIZE | SWP_FRAMECHANGED);
                printf("窗口置顶属性已移除。\n");
                return TRUE;
            }
        }
        
        return FALSE;
    }
    
    // 隐藏窗口
    static BOOL HideTopWindows() {
        // 枚举并隐藏可疑窗口
        printf("隐藏可疑顶层窗口...\n");
        
        // 注意：这种方法可能会影响用户体验
        return FALSE;
    }
    
    // 创建虚假顶层窗口
    static BOOL CreateFakeTopWindows() {
        // 创建一些看似正常的顶层窗口来混淆检测
        printf("创建虚假顶层窗口以混淆检测...\n");
        
        // 实际实现需要注册窗口类并创建窗口
        // 这里仅作概念演示
        
        return TRUE;
    }
};

// 综合绕过方法
VOID ComprehensiveTopWindowBypass() {
    // 修改窗口标题
    TopWindowObfuscator::ChangeTopWindowTitle("Normal Application Window");
    
    // 移除置顶属性
    TopWindowObfuscator::RemoveTopmostStyle(NULL);
    
    // 创建虚假窗口
    TopWindowObfuscator::CreateFakeTopWindows();
    
    printf("顶层窗口检测绕过完成。\n");
}
```

### 4.7 完整测试程序

```cpp
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <vector>
#include <string>

// 前面实现的函数声明
BOOL DetectDebuggersViaGetTopWindow();
BOOL DetectDebuggersViaGetWindow();
BOOL MultiLayerTopWindowDetection();
VOID ComprehensiveTopWindowBypass();

// 显示系统顶层窗口信息
VOID DisplaySystemTopWindowInfo() {
    printf("=== 系统顶层窗口信息 ===\n");
    
    // 获取桌面窗口
    HWND desktop = GetDesktopWindow();
    printf("桌面窗口: 0x%p\n", desktop);
    
    // 获取顶层窗口
    HWND topWindow = GetTopWindow(desktop);
    printf("顶层窗口: 0x%p\n", topWindow);
    
    if (topWindow != NULL) {
        char title[1024];
        GetWindowTextA(topWindow, title, sizeof(title));
        printf("顶层窗口标题: %s\n", title);
    }
    
    // 获取前台窗口
    HWND foreground = GetForegroundWindow();
    printf("前台窗口: 0x%p\n", foreground);
    
    if (foreground != NULL) {
        char title[1024];
        GetWindowTextA(foreground, title, sizeof(title));
        printf("前台窗口标题: %s\n", title);
    }
    
    printf("\n");
}

// 性能测试
VOID PerformanceTest() {
    const int iterations = 100;
    
    printf("=== 性能测试 (%d次调用) ===\n", iterations);
    
    // 测试GetTopWindow方法
    DWORD start = GetTickCount();
    for (int i = 0; i < iterations; i++) {
        DetectDebuggersViaGetTopWindow();
    }
    DWORD getTopWindowTime = GetTickCount() - start;
    
    // 测试GetWindow方法
    start = GetTickCount();
    for (int i = 0; i < iterations; i++) {
        DetectDebuggersViaGetWindow();
    }
    DWORD getWindowTime = GetTickCount() - start;
    
    printf("GetTopWindow方法耗时: %lu ms\n", getTopWindowTime);
    printf("GetWindow方法耗时: %lu ms\n", getWindowTime);
    printf("性能比率: %.2f\n", (float)getWindowTime / getTopWindowTime);
    
    printf("\n");
}

// 主程序
int main() {
    srand((unsigned int)time(NULL));
    
    printf("遍历顶层窗口检测调试器演示程序\n");
    printf("==========================\n\n");
    
    // 显示系统顶层窗口信息
    DisplaySystemTopWindowInfo();
    
    // 显示所有顶层窗口
    TopWindowDetector::PrintTopLevelWindows();
    
    // 分析窗口属性
    TopWindowDetector::AnalyzeWindowProperties();
    
    // 检测已知调试器顶层窗口
    TopWindowDetector::DetectKnownDebuggerTopWindows();
    
    // 检测可疑顶层窗口
    TopWindowDetector::DetectSuspiciousTopWindows();
    
    // 置顶窗口检测
    DetectTopmostDebuggerWindows();
    
    // 所有者关系检测
    DetectDebuggersViaOwnerRelationship();
    
    // 性能测试
    PerformanceTest();
    
    // 实际应用示例
    printf("=== 反调试检测 ===\n");
    if (MultiLayerTopWindowDetection()) {
        printf("检测到调试环境，执行反调试措施。\n");
        
        // 这里可以执行各种反调试措施
        // 为演示目的，我们只是显示信息而不真正退出
        printf("（演示模式：不实际退出程序）\n");
    } else {
        printf("未检测到调试环境，程序正常运行。\n");
        MessageBoxW(NULL, L"顶层窗口检测通过，程序正常运行", L"提示", MB_OK);
    }
    
    // 演示绕过方法
    printf("\n=== 绕过演示 ===\n");
    printf("执行顶层窗口绕过...\n");
    ComprehensiveTopWindowBypass();
    
    printf("绕过完成后再次检测：\n");
    if (MultiLayerTopWindowDetection()) {
        printf("仍然检测到调试环境。\n");
    } else {
        printf("检测结果显示未发现调试器顶层窗口。\n");
    }
    
    return 0;
}
```

### 4.8 高级技巧和注意事项

```cpp
// 抗干扰版本（防止简单的Hook）
BOOL AntiTamperTopWindowDetection() {
    // 多次调用并验证
    BOOL results[5];
    
    for (int i = 0; i < 5; i++) {
        results[i] = MultiLayerTopWindowDetection();
        Sleep(10);  // 简短延迟
    }
    
    // 检查结果一致性
    for (int i = 1; i < 5; i++) {
        if (results[i] != results[0]) {
            // 结果不一致，可能是被干扰了
            return TRUE;  // 假设存在调试环境
        }
    }
    
    return results[0];
}

// 时间差检测增强版
BOOL TimeBasedTopWindowDetection() {
    DWORD start = GetTickCount();
    
    // 执行多次顶层窗口检测
    for (int i = 0; i < 10; i++) {
        if (MultiLayerTopWindowDetection()) {
            return TRUE;
        }
    }
    
    DWORD end = GetTickCount();
    
    // 如果执行时间过长，可能是被调试
    if ((end - start) > 1000) {  // 超过1秒
        return TRUE;
    }
    
    return FALSE;
}

// 综合检测函数
BOOL ComprehensiveTopWindowDetection() {
    // 抗干扰检测
    if (AntiTamperTopWindowDetection()) {
        return TRUE;
    }
    
    // 时间差检测
    if (TimeBasedTopWindowDetection()) {
        return TRUE;
    }
    
    // 其他顶层窗口检测
    if (TopWindowDetector::DetectSuspiciousTopWindows()) {
        return TRUE;
    }
    
    return FALSE;
}

// 动态获取API地址（避免静态导入）
FARPROC GetDynamicAPIAddress(LPCSTR moduleName, LPCSTR functionName) {
    // 动态加载模块
    HMODULE hModule = LoadLibraryA(moduleName);
    if (hModule == NULL) {
        return NULL;
    }
    
    // 获取函数地址
    FARPROC pfn = GetProcAddress(hModule, functionName);
    
    return pfn;
}

// 检测窗口枚举的完整性
BOOL ValidateTopWindowEnumeration() {
    // 可以通过多次枚举并比较结果来检测是否被干扰
    auto firstScan = GetAllTopLevelWindows();
    Sleep(100);
    auto secondScan = GetAllTopLevelWindows();
    
    // 比较两次扫描的结果
    if (firstScan.size() != secondScan.size()) {
        return TRUE;  // 可能被干扰了
    }
    
    // 进一步比较具体内容...
    
    return FALSE;
}

// 检测窗口属性的完整性
BOOL ValidateWindowProperties(HWND hwnd) {
    // 检查窗口属性是否被修改
    LONG style = GetWindowLong(hwnd, GWL_STYLE);
    LONG exStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
    
    // 可以添加更多的验证逻辑...
    
    return TRUE;
}
```

## 五、课后作业

1. **基础练习**：
   - 在不同Windows版本下测试上述代码的兼容性
   - 扩展调试器窗口标题列表，添加更多现代调试器
   - 实现对窗口类名的检测而不仅仅是窗口标题

2. **进阶练习**：
   - 实现一个顶层窗口监控器，实时监控调试器窗口的出现和消失
   - 研究如何检测通过修改窗口属性绕过检测的调试器
   - 设计一个多层检测机制，结合多种顶层窗口检测技术

3. **思考题**：
   - 顶层窗口检测方法相比普通窗口检测有哪些优势？
   - 如何提高顶层窗口检测的准确性和隐蔽性？
   - 现代调试器采用了哪些技术来对抗顶层窗口检测？

4. **扩展阅读**：
   - 研究Windows窗口管理层级机制
   - 了解窗口Z轴顺序管理
   - 学习现代反反调试技术